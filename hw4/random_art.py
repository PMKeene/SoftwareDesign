# -*- coding: utf-8 -*-
"""
Created on Tue Feb 11 11:34:57 2014

@author: pruvolo
"""

# you do not have to use these particular modules, but they may help
from random import randint
import math
import Image

def build_random_function(min_depth, max_depth):
    """builds a list with nested lists that signifies a randomly created list
    with a nested level somewhere between min and max depth.
    
    takes min_depth (positive interger or 0) and max_depth (larger positive interger)
    """
    #guardian statements determine what your options are depending on where we are in our recursion tree
    if min_depth>0:
        path=randint(1,5)
        
    if (min_depth<=0) and (max_depth>0):
        path=randint(1,7)
    
    if max_depth<=0:
        path=randint(6,7)
    #and implement the chosen option, returning lovely nested lists with lots of recursion!!
    if path==1:
        return ["prod",build_random_function(min_depth-1,max_depth-1),build_random_function(min_depth-1,max_depth-1)]
    if path==2:
        return ["cos_pi",build_random_function(min_depth-1,max_depth-1)]
    if path==3:
        return ["sin_pi",build_random_function(min_depth-1,max_depth-1)]
    if path==4:
        return ["arctan",build_random_function(min_depth-1,max_depth-1)]
    if path==5:
        return ["squared",build_random_function(min_depth-1,max_depth-1)]
    if path==6:
        return ["y"]
    if path==7:
        return ["x"]

def evaluate_random_function(f, x, y):
    """produces a numerical evaluation of a function generated by build_random_function 
    for any given x and y values.
    
    input: (nested)list of strings indicating function names of basic 
    permitted functions and their arguments, and two values (float or int)
    output: float value"""
    #do math! follow the instructions set out in the string you are fed bythe output of the function builder
    #print f #, just in case you would like to know what part/the function it's working on
    if f[0]=="prod":
        return evaluate_random_function(f[1],x,y)*evaluate_random_function(f[2],x,y)
    if f[0]=="cos_pi":
        return math.cos(math.pi*evaluate_random_function(f[1],x,y))
    if f[0]=="sin_pi":
        return math.sin(math.pi*evaluate_random_function(f[1],x,y))
    if f[0]=="arctan":
        return math.atan(evaluate_random_function(f[1],x,y))
    if f[0]=="squared":
        return evaluate_random_function(f[1],x,y)**2
    if f[0]=="x":
        return x
    if f[0]=="y":
        return y
    #"unit tested" until I saw all the functions from the command line and confirmed values

def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
    """ Maps the input value that is in the interval [input_interval_start, input_interval_end]
        to the output interval [output_interval_start, output_interval_end].  The mapping
        is an affine one (i.e. output = input*c + b).
    
        input: a value (float or interger) followed by the input interval expressed as floats and the output interval in floats
        output: a float that expresses the input value in terms of the new interval
    """
    #where the value is in the first interval multiplied by the range of the second interval and added to the new base    
    return (val-input_interval_start)/(input_interval_end-input_interval_start)*(output_interval_end-output_interval_start)+output_interval_start

def PrettyLittlePicture(min_depth, max_depth):
    #we want to use the same function for each channel of every pixel
    #we could putz around with the depths of each color, but this is the base
    redfunc=build_random_function(min_depth,max_depth)
    bluefunc=build_random_function(min_depth+1,max_depth+2)
    greenfunc=build_random_function(min_depth+3,max_depth+4)
    #now we need a set of pixels to write to
    im=Image.new("RGB",(350,350),"black")
    #and something to talk about writing to
    pixelMap=im.load()
    #then for every pixel...
    for rx in range(349):
        for ry in range(349):
            #we turn its coordinates into acceptable inputs
            mx=remap_interval(rx,0.0,349.0,-1.0,1.0)
            my=remap_interval(ry,0.0,349.0,-1.0,1.0)
            #do a little math with the functions we made up before and turn it into an int in the interval [0,255]
            red=int(remap_interval(evaluate_random_function(redfunc,mx,my),-1.0,1.0,0.0,255.0))
            green=int(remap_interval(evaluate_random_function(greenfunc,mx,my),-1.0,1.0,0.0,255.0))
            blue=int(remap_interval(evaluate_random_function(bluefunc,mx,my),-1.0,1.0,0.0,255.0))
            #and write it to the pixel
            pixelMap[rx,ry]=(red,green,blue)
    #then save to check out later
    im.save("my_art16.png")

if __name__ == "__main__":
    PrettyLittlePicture(9,15)